// 배열 - 배열 레퍼런스와 배열 인스턴스의 관계
//        부제: 가비지와 가비지 컬렉터
package step02; 

public class Exam09_4 {
    public static void main(String[] args) {
        int[] arr1;
        arr1 = new int[]{100, 200, 300};

        System.out.println(arr1[0]);
        System.out.println(arr1[1]);
        System.out.println(arr1[2]);

        // 새로운 int 배열을 확보하여 arr1 레퍼런스에 그 주소를 저장한다.
        // => arr1 변수에는 새 배열의 주소가 저장된다.
        // => 그러면 이전 배열의 주소는 잃어 버린다.
        // => 주소를 잃어버린 배열은 사용할 수 없다.
        // => 이렇게 사용할 수 없는 메모리(인스턴스)를
        //    가비지(garbage)라 부른다.
        // => 가비지는 개발자가 임의로 제거할 수 없다.

        arr1 = new int[]{10, 20, 30, 40, 50};
        System.out.println(arr1[0]);
        System.out.println(arr1[1]);
        System.out.println(arr1[2]);

        System.out.println(arr1);

    }
}

// 가비지(garbage)/
// - 주소를 잃어버려 사용할 수 없는 메모리(인스턴스)
// - JVM을 종료하면 어차피 OS에게 사용한 메모리를 반납해야 하기 때문에
//   자동으로 해제된다.
// - 그러나 JVM이 실행하는 중에 개발자가 임의로 해제할 수 없다.
// - 오직 가비지 컬렉터(garbage collector)만이 가비지를 해제할 수 있다.
//
// 가비지 컬렉터(garbage collector)
// - 인스턴스의 주소를 알고 있는 변수가 없을 경우
//   그 인스턴스는 가비지로 간주된다.
// - 가비지 메모리를 재사용 할 수 있도록 해제시키는 방법
//   => 개발자가 임의로 해제 불가능하다.
//   => 가비지 컬렉터가 실행 되어야만 해제시킬 수 있다.
//
// 가비지 컬렉터의 실행
// - 다음의 경우에 가비지 컬렉터가 실행되어 가비지들이 해제된다.
// 1) 메모리가 부족할 경우
//    - OS에게 메모리를 요청하기 전에 먼저 가비지를 청소한 다음에
//      요청할 지 말지 결정한다.
// 2) CPU가 한가할 때
//    - 24시간, 365일 내내 멈춤없이 JVM이 실행될 경우,
//      CPU가 한가한 시간에 가비지를 청소할 수 있다.
//    - 정확히 언제인지 시간을 지정하거나 예측할 수는 없다.
// 3) 개발자가 가비지 컬렉터를 실행하라고 명령을 내릴 때
//    - 명령을 내린다고 즉시 실행되는 것은 아니다.
//    - 일종의 빠른 시일 내에 가비지를 실행하라고 JVM에 예약하는 것이다.
// 결론!
// - 가비지는 가비지 컬렉터가 자기 나름의 조건에 따라 실행할 것이니,
//   개발자는 신경쓰지 말라!
// - 만약 메모리를 개발자가 마음대로 조작하고 싶으면,
//   C/C++로 프로그래밍하라!
// - 가비지 컬렉터라는 개념을 등장시킨 이유는,
//   C/C++ 개발자들이 메모리를 자기 마음대로 조작하다가
//   시스템에 치명적인 문제들을 자주 일으켰기 때문에
//   그것을 차단하기 위해서 나온 개념이다.
//   (메모리 사용 효율을 극대화하고싶기 때문)
// - 그러니 가비지 컬렉터를 개발자가 임의로 동작시키는 것 자체가
//   가비지 컬렉터의 존재 이유를 무시하는 것이 되기 때문에
//   따라서 메모리를 임의로 해제할 생각을 말라!
//
// 가비지 컬렉션(garbage collection)?
// - 가비지 컬렉터를 통해서 가비지를 해제시키는 것.
//
// 가비지 컬렉션 방식의 문제점?
// - 가비지 컬렉터가 실행되기 전까지는 일정시간 쓰레기 메모리가 
//   유지되게 된다.
// - 메모리 사용율을 극한으로 끌어 올릴 수 없다.
// - 근데 너무 메모리 사용에 대해 짜게 굴지 말라!
//   왜?
//   요즘 메모리 값이 싸다!

//  그래서 소스코드가 길어도 가비지 컬렉터가 동작하지 않을수도 있다.
//  but JVM실행이 끝나면 어차피 메모리를 모두 반납하기 때문에 괜찮다.
// cf) C#, JavaScript, Python등의 스크립트 언어, 
//     대부분의 현대적인 언어에서 가비지 컬렉터를 사용한다.
